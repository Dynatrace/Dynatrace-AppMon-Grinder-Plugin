/**
 * This template file was generated by dynaTrace client.
 * The dynaTrace community portal can be found here: http://community.dynatrace.com/
 * For information how to publish a plugin please visit http://community.dynatrace.com/plugins/contribute/
 **/

package org.measuredprogress.dynatrace.plugin.monitor.grinder;

import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URISyntaxException;
import java.net.URL;
import java.util.Arrays;
import java.util.Collection;
import java.util.logging.Logger;

import org.apache.http.HttpEntity;
import org.apache.http.HttpResponse;
import org.apache.http.ParseException;
import org.apache.http.StatusLine;
import org.apache.http.client.ClientProtocolException;
import org.apache.http.client.ResponseHandler;
import org.apache.http.client.fluent.Request;
import org.apache.http.util.EntityUtils;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import com.dynatrace.diagnostics.pdk.Monitor;
import com.dynatrace.diagnostics.pdk.MonitorEnvironment;
import com.dynatrace.diagnostics.pdk.MonitorMeasure;
import com.dynatrace.diagnostics.pdk.Plugin;
import com.dynatrace.diagnostics.pdk.Status;
import com.dynatrace.diagnostics.pdk.TaskEnvironment;

public class RecordingData implements Monitor {

	private static final String TOTALS = "totals";

	private static final Logger log = Logger.getLogger(RecordingData.class
			.getName());

	private static final String METRIC_GROUP = "GrinderData";

	/*
	 * Predefined metrics. The values must match metrics names specified in the
	 * Metrics section of the Configure Metric Groups and Metrics step in the
	 * Plugin Wizard or the nested metric elements under the metricgroup element
	 * in the plugin.xml
	 */
	private static final String TOTAL_TESTS_EXECUTED = "TestsExecuted";
	private static final String TOTAL_ERROR_COUNT = "ErrorCount";
	private static final String TOTAL_RESPONSE_TIME = "TotalResponseTime";
	private static final String TOTAL_STD_DEV = "TotalStandardDeviation";
	private static final String TOTAL_TPS = "TotalTPS";
	private static final String TOTAL_PEAK_TPS = "TotalPeakTPS";

	/*
	 * Ordinal positions for each field with the JSONArray returned by the
	 * grinder.
	 */
	private static final Integer POS_TESTS = 0;
	private static final Integer POS_ERROR_COUNT = 1;
	private static final Integer POS_RESPONSE_TIME = 2;
	private static final Integer POS_STD_DEVIATION = 3;
	private static final Integer POS_TPS = 4;
	private static final Integer POS_PEAK_TPS = 5;

	private URL url;

	@SuppressWarnings("unused")
	private String host;

	/**
	 * Initializes the Plugin. This method is called in the following cases:
	 * <ul>
	 * <li>before <tt>execute</tt> is called the first time for this scheduled
	 * Plugin</li>
	 * <li>before the next <tt>execute</tt> if <tt>teardown</tt> was called
	 * after the last execution</li>
	 * </ul>
	 * <p>
	 * If the returned status is <tt>null</tt> or the status code is a
	 * non-success code then {@link Plugin#teardown() teardown()} will be called
	 * next.
	 * <p>
	 * Resources like sockets or files can be opened in this method.
	 * 
	 * @param env
	 *            the configured <tt>MonitorEnvironment</tt> for this Plugin;
	 *            contains subscribed measures, but <b>measurements will be
	 *            discarded</b>
	 * @see Plugin#teardown()
	 * @return a <tt>Status</tt> object that describes the result of the method
	 *         call
	 */
	@Override
	public Status setup(MonitorEnvironment env) throws Exception {
		try {

			host = env.getHost().getAddress();

			url = new URL(env.getConfigUrl("grinder.host.url"),
					env.getConfigString("grinder.recording.data"));
		} catch (MalformedURLException e) {
			log.warning(e.getMessage());
			return new Status(
					Status.StatusCode.ErrorInternalConfigurationProblem,
					e.getMessage());
		}

		return new Status(Status.StatusCode.Success);
	}

	/**
	 * Executes the Monitor Plugin to retrieve subscribed measures and store
	 * measurements.
	 * 
	 * <p>
	 * This method is called at the scheduled intervals. If the Plugin execution
	 * takes longer than the schedule interval, subsequent calls to
	 * {@link #execute(MonitorEnvironment)} will be skipped until this method
	 * returns. After the execution duration exceeds the schedule timeout,
	 * {@link TaskEnvironment#isStopped()} will return <tt>true</tt>. In this
	 * case execution should be stopped as soon as possible. If the Plugin
	 * ignores {@link TaskEnvironment#isStopped()} or fails to stop execution in
	 * a reasonable timeframe, the execution thread will be stopped ungracefully
	 * which might lead to resource leaks!
	 * 
	 * @param env
	 *            a <tt>MonitorEnvironment</tt> object that contains the Plugin
	 *            configuration and subscribed measures. These
	 *            <tt>MonitorMeasure</tt>s can be used to store measurements.
	 * @return a <tt>Status</tt> object that describes the result of the method
	 *         call
	 */
	@Override
	public Status execute(MonitorEnvironment env) throws Exception {

		JSONObject response = getJSONMeasures();
		log.fine("Response: " + response.toString());

		/**
		 * % curl http://localhost:6373/recording/data
		 * 
		 * {"status":{"state":"Stopped","description":"Collection stopped"},
		 * "columns":["Tests","Errors","Mean Test Time (ms)",
		 * "Test Time Standard Deviation (ms)","TPS","Peak TPS"],
		 * "tests":[{"test"
		 * :1,"description":"Log method","statistics":[30,0,0.2,0.4
		 * ,9.674298613350532, 9.67741935483871]}],
		 * "totals":[30,0,0.2,0.4,9.674298613350532,9.67741935483871]}
		 */

		JSONArray totals = response.getJSONArray(TOTALS);

		Double[] stats = new Double[totals.length()];
		for (int j = 0; j < stats.length; j++) {
			stats[j] = totals.getDouble(j);

		}
		log.fine("The stats: " + Arrays.asList(stats));

		Collection<MonitorMeasure> measures = env.getMonitorMeasures(
				METRIC_GROUP, TOTAL_ERROR_COUNT);
		if (measures == null) {
			return new Status(Status.StatusCode.ErrorInternal,
					"failed to get monitor measures");
		}
		for (MonitorMeasure measure : measures) {
			log.fine("Setting measure " + TOTAL_ERROR_COUNT);
			measure.setValue(stats[POS_ERROR_COUNT]);
		}

		measures = env.getMonitorMeasures(METRIC_GROUP, TOTAL_TESTS_EXECUTED);
		if (measures == null) {
			return new Status(Status.StatusCode.ErrorInternal, "failed to get "
					+ TOTAL_TESTS_EXECUTED + " monitor measures");
		}
		for (MonitorMeasure measure : measures) {
			log.fine("Setting measure " + TOTAL_TESTS_EXECUTED);
			measure.setValue(stats[POS_TESTS]);
		}

		measures = env.getMonitorMeasures(METRIC_GROUP, TOTAL_RESPONSE_TIME);
		if (measures == null) {
			return new Status(Status.StatusCode.ErrorInternal, "failed to get "
					+ TOTAL_RESPONSE_TIME + " monitor measures");
		}
		for (MonitorMeasure measure : measures) {
			log.fine("Setting measure " + TOTAL_RESPONSE_TIME);
			measure.setValue(stats[POS_RESPONSE_TIME]);
		}
		measures = env.getMonitorMeasures(METRIC_GROUP, TOTAL_STD_DEV);
		if (measures == null) {
			return new Status(Status.StatusCode.ErrorInternal, "failed to get "
					+ TOTAL_STD_DEV + " monitor measures");
		}
		for (MonitorMeasure measure : measures) {
			log.fine("Setting measure " + TOTAL_STD_DEV);
			measure.setValue(stats[POS_STD_DEVIATION]);
		}

		measures = env.getMonitorMeasures(METRIC_GROUP, TOTAL_TPS);
		if (measures == null) {
			return new Status(Status.StatusCode.ErrorInternal, "failed to get "
					+ TOTAL_TPS + " monitor measures");
		}
		for (MonitorMeasure measure : measures) {
			log.fine("Setting measure " + TOTAL_TPS);
			measure.setValue(stats[POS_TPS]);
		}

		measures = env.getMonitorMeasures(METRIC_GROUP, TOTAL_PEAK_TPS);
		if (measures == null) {
			return new Status(Status.StatusCode.ErrorInternal, "failed to get "
					+ TOTAL_PEAK_TPS + " monitor measures");
		}
		for (MonitorMeasure measure : measures) {
			log.fine("Setting measure " + TOTAL_PEAK_TPS);
			measure.setValue(stats[POS_PEAK_TPS]);
		}

		// }

		return new Status(Status.StatusCode.Success);
	}

	private JSONObject getJSONMeasures() throws ClientProtocolException,
			IOException, URISyntaxException {
		return Request.Get(url.toURI()).execute()
				.handleResponse(new ResponseHandler<JSONObject>() {
					public JSONObject handleResponse(final HttpResponse response)
							throws IOException {
						StatusLine statusLine = response.getStatusLine();

						if (statusLine.getStatusCode() != 200) {
							String msg = "Unexepected response %s (%d) from server";
							throw new IOException(String.format(msg,
									statusLine.getReasonPhrase(),
									statusLine.getStatusCode()));
						}

						HttpEntity entity = response.getEntity();
						JSONObject json;
						try {
							json = new JSONObject(EntityUtils.toString(entity));
						} catch (ParseException e) {
							throw new IOException(e);
						} catch (JSONException e) {
							// TODO Auto-generated catch block
							throw new IOException(e);
						}

						return json;
					}

				});
	}

	/**
	 * Shuts the Plugin down and frees resources. This method is called in the
	 * following cases:
	 * <ul>
	 * <li>the <tt>setup</tt> method failed</li>
	 * <li>the Plugin configuration has changed</li>
	 * <li>the execution duration of the Plugin exceeded the schedule timeout</li>
	 * <li>the schedule associated with this Plugin was removed</li>
	 * </ul>
	 * 
	 * <p>
	 * The Plugin methods <tt>setup</tt>, <tt>execute</tt> and <tt>teardown</tt>
	 * are called on different threads, but they are called sequentially. This
	 * means that the execution of these methods does not overlap, they are
	 * executed one after the other.
	 * 
	 * <p>
	 * Examples:
	 * <ul>
	 * <li><tt>setup</tt> (failed) -&gt; <tt>teardown</tt></li>
	 * <li><tt>execute</tt> starts, configuration changes, <tt>execute</tt> ends
	 * -&gt; <tt>teardown</tt><br>
	 * on next schedule interval: <tt>setup</tt> -&gt; <tt>execute</tt> ...</li>
	 * <li><tt>execute</tt> starts, execution duration timeout, <tt>execute</tt>
	 * stops -&gt; <tt>teardown</tt></li>
	 * <li><tt>execute</tt> starts, <tt>execute</tt> ends, schedule is removed
	 * -&gt; <tt>teardown</tt></li>
	 * </ul>
	 * Failed means that either an unhandled exception is thrown or the status
	 * returned by the method contains a non-success code.
	 * 
	 * 
	 * <p>
	 * All by the Plugin allocated resources should be freed in this method.
	 * Examples are opened sockets or files.
	 * 
	 * @see Monitor#setup(MonitorEnvironment)
	 */
	@Override
	public void teardown(MonitorEnvironment env) throws Exception {
		// Nothing to do here.
	}

	
}
